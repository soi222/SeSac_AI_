newline = '\n'

class TictactoeGame:
    """Wrapper class for Tictactoe game. 

    For the explanation of tictactoe game, see https://namu.wiki/w/%ED%8B%B1%ED%83%9D%ED%86%A0. 

    In tictactoe game, you are asked to write following methods. For specification of each method, see each method's docstring. For the question, you are asked to write following functions; 

    - empty_board
    - check_winlose
    - play 
    - display 

    The core function that will be used in the simulation is display. The display function will draw the current board status, reflecting all previous moves. 

    Once you have succeessfully implemented above four functions, you will be than asked to make a game-playing player, generalize the given functions, write the function for generic display, etc,.. 

    Todos

    1) Implement following methods for TictactoeGame class; empty_board, check_winlose, play, display. For each function details, see the docstrings in each function. 
    1-1) For function empty_board, generalize the function to accept arbiary cell size. The arguments x_cell_size and y_cell_size should be added. 
    2) Implement the function smart_player in the player.py file. For the function details, see the docstrings in each function. 

    Optional Todos 

    1) Implement method board_with_content, count_consequtive for class TictactoeGame. 
    2) Generalize the class TictactoeGame to accept arbitary size and winning conditions. 
    3) Based on the generalization done in 2), re-implement the smart_player function in the player.py file.

    Very Optional Todos (Maybe for later)

    1) Implement the game of go on grid. 
    2) Implement the winning condition for the game of go. 
    3) Implement the game of go on generic graph. 

    Attributes:
        list x_positions 
        list o_poistions 
        int x_size (default 3) 
        int y_size (default 3) 
    Methods: 
        str empty_board(int x_cell_size, int y_cell_size): Returns an empty board with given cell size. 
        str check_winlose(): Returns the current win-lose-tie status of the game. 
        void play(str x_or_o, tuple[int] coordinate): Reflect the move of x_or_o side on coordinate.  
        void display(): Prints the current snapshot of the game. 
        
        (optional) str board_with_content(int x_cell_size, int y_cell_size, callable content): Print the board with contents dedicated for each cell. Cell-specific contents will be generated by the function content. 
        (optional) int count_conseutive(list[tuple[int]] lst): Count the max consequtive sequence from given list of coordinates. 
    
    All other methods are auxillary methods for implmentation. 
    """
    def __init__(self, x_positions = [], o_positions = [], x_size = 3, y_size = 3):
        self.x_positions = []
        self.o_positions = []
        self.x_size = x_size
        self.y_size = y_size
    
    def empty_board(self, x_cell_size = 5, y_cell_size = 3):
        """Create an empty board. 

        The board is made of horizontal lines, made with - and vertical lines, made with |. 

        (optional) When there are no x_cell_size and y_cell_size arguments, default to arbitary size of your choice. Just make it consistent. 
        """
        v = '|' + ' ' * x_cell_size 
        h = ' ' + '-' * x_cell_size
        board = ''
        
        for y in range(0, self.y_size):
            for x in range(0, self.x_size):
                board += h 
            board += newline
            for c in range(y_cell_size):
                for x in range(0, self.x_size):
                    board += v      
                board += v + newline
        for x in range(0, self.x_size):
            board += h 
        
        return board 

    def play(self, x_or_o, coordinate):
        """Main function for simulating tictactoe game moves. 

        Tictactoe game is executed by two player's moves. In each move, each player chooses the coordinate to place their mark. It is impossible to place the mark on already taken position. 

        A move in the tictactoe game is composed of two components; whether who ('X' or 'O') made the move, and how the move is made - the coordinate of the move. 

        Coordinate in our tictactoe system will use the coordinate system illustrated in the example below. 
        
        Example 1. 3 * 4 tictactoe board. 
        
             ---------- ---------- ----------
            |          |          |          |
            |  (0,0)   |  (1,0)   |  (2,0)   |
            |          |          |          |
             ---------- ---------- ----------
            |          |          |          |
            |  (0,1)   |  (1,1)   |  (2,1)   |
            |          |          |          |
             ---------- ---------- ----------
            |          |          |          |
            |  (0,2)   |  (1,2)   |  (2,2)   |
            |          |          |          |
             ---------- ---------- ----------
            |          |          |          |
            |  (0,3)   |  (1,3)   |  (2,3)   |
            |          |          |          |
             ---------- ---------- ----------
        """
        if coordinate in self.x_positions + self.o_positions:
            raise ValueError(f'{coordinate} already taken')

        if x_or_o == 'X':
            self.x_positions.append(coordinate)
        elif x_or_o == 'O':
            self.o_positions.append(coordinate)
        else:
            raise ValueError(f'{x_or_o} is not a valid move type; should be one of X or O.')
    
    def check_winlose(self):
        """Check the game status; game status should be one of 'X wins', 'O wins', 'tie', 'not decided'. 
        """
        x_win = self.check_winning_tictactoe(self.x_positions)
        o_win = self.check_winning_tictactoe(self.o_positions)

        if x_win:
            return 'X wins'
        elif o_win:
            return 'O wins'
        elif len(set(self.x_positions + self.o_positions)) == 9:
            return 'tie'
        else:
            return 'not decided' 
    
    def check_winning_tictactoe(self, positions):
        winning_combinations = [
            [(0, 0), (0, 1), (0, 2)],
            [(1, 0), (1, 1), (1, 2)],
            [(2, 0), (2, 1), (2, 2)],
            [(0, 0), (1, 0), (2, 0)],
            [(0, 1), (1, 1), (2, 1)],
            [(0, 2), (1, 2), (2, 2)],
            [(0, 0), (1, 1), (2, 2)],
            [(0, 2), (1, 1), (2, 0)]
        ]
        for combo in winning_combinations:
            if all(pos in positions for pos in combo):
                return True
        return False

    def display(self):
        """Display the current snapshot of the board. 

        'Snapshot' should contain following components. 

        - The board itself 
        - Moves that are already made

        For clarification, see provided examples. 

        Example 1. 
        When TictactoeGame instance t have following attributes; 
        - x_positions = [(0,0), (2,0), (2,1), (1,2)]
        - o_positions = [(1,0), (1,1), (0,2), (2,2)]

        t.display()
        >> 
         ---------- ---------- ----------
        |          |          |          |
        |    X     |    O     |    X     |
        |          |          |          |
         ---------- ---------- ----------
        |          |          |          |
        |          |    O     |    X     |
        |          |          |          |
         ---------- ---------- ----------
        |          |          |          |
        |    O     |    X     |    O     |
        |          |          |          |
         ---------- ---------- ----------

        """
        def f(x, y):
            if (x,y) in self.x_positions:
                return 'X'
            if (x,y) in self.o_positions:
                return 'O'
            
            return ''
        print()
        print(self.board_with_content(content = f))
    
    #----------------------------------------------------
    # Optional Methods 
    #----------------------------------------------------

    def board_with_content(self, x_cell_size = 10, y_cell_size = 3, content = lambda x,y:f'({x},{y})'):
        v = '|' + ' ' * x_cell_size 
        h = ' ' + '-' * x_cell_size
        board = ''
        
        for y in range(0, self.y_size):
            for x in range(0, self.x_size):
                board += h 
            board += newline
            for c in range(y_cell_size):
                for x in range(0, self.x_size):
                    if c == y_cell_size//2:
                        text = content(x, y)
                        l = len(text)
                        space = ' ' * ((x_cell_size-l)//2)
                        board += '|' + space + text + space + ' ' * ((x_cell_size-l)%2)
                    else:
                       board += v      
                board += v + newline
        for x in range(0, self.x_size):
            board += h 
        
        return board 


    @classmethod
    def count_consequtive(lst):
        pass 
    